#!/usr/bin/env python
# coding: utf-8

# In[1]:


# 1. Basic syntax and variables
x = 10
y = 5
print("sum", x+y)


# In[2]:


# 2 Data Type and type conversion

a = 5 
b = 3.2
c = "123"

# type conversion 

a_to_float = float(a)
b_to_str = str(b)
c_to_int = int(c)

print(a_to_float, type(a_to_float))
print(b_to_str, type(b_to_str))
print(c_to_int, type(c_to_int))


# In[3]:


# 3 control Flow : If - Else

num = 10
if num > 0:
    print("possitive")
elif num < 0:
    print("Negative")
else:
    print(None)


# In[4]:


# 4 Loops: For and While

n = 5
for i in range(n):
    print(i, end = " ")


# In[5]:


counter = 0
while counter < 5:
    print("Counter is", counter, end = ",")
    counter += 1


# Input:
# x = 10
# Output:
# 1 4 9

# In[17]:


def printIncreasingPower(x):
    for i in range(x):
        if i>0 and i**2<=x:
            print(i**2, end= " ")
            
printIncreasingPower(10)


# In[1]:


def printIncreasingPower(x):
    i = 1
    
    while(i**2 <= x):
        ##Your code here
        
        print (i**2, end = " ")
        i+=1
        
printIncreasingPower(10)


# In[2]:


def multiplicationTable(N):## in is a membership operator that is true if something is a member of sequence
    for i in range(1,11): ## i in range(x,y,z) means i goes from x to y-1 and increments z steps in each iteration
        print(i * N, end=" ")
        
multiplicationTable(5)


# In[6]:


# 5 functions 

def fibonacci(N):
    a = 0
    b = 1
    for i in range(N):
        print(a, end= " ")
        a, b = b, a+b      
fibonacci(20)


# In[11]:


def pos(n):
    for i in range(n,-1,-1):
        print(i)
        
    
def neg(n):
    for i in range(n,1):
        print(i)
    
pos(4)

neg(-3)


# In[7]:


# 6 Lists and List Comprehension

my_list = [1,2,3,4,5]

squares = [x ** 2 for x in my_list]
print("Squared Numbers", squares)


# In[1]:


# heapq
import heapq

lst1 = [1, 2, 3, 5]
lst2 = [2, 3, 4, 5, 6]

res = list(heapq.merge(lst1, lst2))

print(res)


def merged_sorted_lists(lst1, lst2):
    return sorted(lst1 + lst2)

print("Merged_sorted_list=>",merged_sorted_lists(lst1,lst2))


# In[8]:


# 7 Dictionary 

person = {
    'name':'Alice',
    'age':30,
    'profession':'Engineer'
}

# Accessing dictionary values

print(person['name'])
print(person.get('profession'))

# Adding a new key-value pair

person['city'] = 'Berlin'
print(person)


# In[9]:


# 8. sets

# sets and basic opearations

fruits = {"apple","banana","cherry"}
fruits.add("orange")
print(fruits)
fruits.remove("banana")
print(fruits)


# In[10]:


# 9 Tuples

My_tuple = (1,2,3)

print(My_tuple)

# Tuple unpacking
a , b , c = My_tuple
print(a, b , c)

print(*My_tuple)


# In[11]:


# 10. file handling

# writing to a file

with open("file1.txt", "w") as file:
    file.write("Hello, World!")
    
# Reading From a file

with open("file1.txt", "r") as file:
    content = file.read()
    print(content)


# In[12]:


# 11. EXception Handling 

try:
    result = 10/0
except ZeroDivisionError:
    print("cannot divide by Zero")
finally:
    print("this runs no matter what")


# In[2]:


# 12. Classes and objects

# Class definition and object creation

class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
        
    def bark(self):
        return f"{self.name} says woof!"
    
    def species(self):
        return f"{self.name} is {self.breed}"
    

# Creting an object

my_dog = Dog("Buddy", "Golden Retriver")

print(my_dog.bark())
print(my_dog.species())


# In[14]:


# 13 Magic Methods and operator overloading

# opeartor overloading

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
    
    def __str__(self):
        return f"Point({self.x}, {self.y})"
    
p1 = Point(1, 2)
p2 = Point(7, 9)
result = p1 + p2 # this is uses add method (Magic Method)
print(result) # uses __str__ method


# In[15]:


# 14. Lambda and Map Functions

nums = [1, 2, 3, 4, 5]

squares = list(map(lambda x: x**2, nums))
print(squares)


# In[16]:


# a}  Basic Syntax:
    
add = lambda a, b: a + b
print(add(2, 3))  


# In[17]:


# b}  Lambda with map()

numbers = [1, 2, 3, 4, 5]
squares = list(map(lambda x: x ** 2, numbers))
print(squares)


# In[18]:


# c}  Lambda with filter()

numbers = [1, 2, 3, 4, 5, 6]
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)


# In[19]:


# d}  Lambda with reduce()

from functools import reduce

numbers = [1, 2, 3, 4]
product = reduce(lambda x, y: x * y, numbers)
print(product)


# In[20]:


#  e} Lambda inside a function

def power(n):
    return lambda x: x ** n

square = power(2)
cube = power(3)

print(square(5)) 
print(cube(2))    


# In[21]:


# f}  Sorting with a lambda function

pairs = [(1, 'one'), (2, 'two'), (3, 'three')]
sorted_pairs = sorted(pairs, key=lambda x: x[1])
print(sorted_pairs)


# In[22]:


# 15 List Sorting Values (descending)

scores = {'Alice': 70, 'Bob': 85, 'Charlie': 60}
sorted_scores = dict(sorted(scores.items(),key = lambda x:x[1], reverse = True))
print(sorted_scores)


# In[23]:


# 16 Generators

# GEnerator Example 

def countdown(num):
    while num > 0:
        yield num
        num -= 1

print(countdown(5))
print(*countdown(5))
# for number in countdown(5):
#     print(number)


# In[24]:


# 17 Decorators

def greet_decorator(func):
    def wrapper(name):
        print("Before Greeting")
        func(name)
        print("After Greeting")
    return wrapper

@greet_decorator
def greet(name):
    print(f"Hello, {name}")

greet("Sairaj")


# In[25]:


# 18 Working with Pandas
import pandas as pd
data = { 
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Age': [25, 30, 35]
}

df = pd.DataFrame(data)

print(df)


# # 19 Web Scraping with requests and BeautifulSoup
# 
# import requests
# from bs4 import BeautifulSoup
# 
# url = ""
# 
# response = requests.get(url)
# 
# soup = BeautifulSoup(response.txt, 'html.parser')
# 
# print(soup.title.text)

# In[26]:


# 20 Multithreading

import threading

def print_numbers():
    for i in range(5):
        print(i)

# Creating a thread
thread = threading.Thread(target=print_numbers)
thread.start()
thread.join() # wait for the thread to complete


# In[27]:


# 21. Recursion

def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)
print(factorial(5))


# In[28]:


# 22 Binary Search Algorithm

# Binary Search in Sorted list

def binary_search(arr, target):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid+1
        else:
            high = mid -1
    return -1

arr = [1, 3, 5, 7, 9]
print(binary_search(arr, 7))


# In[29]:


# 23. Fibonacci Sequence (Recursion)

def fibonacci(n):
    if n <= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)
    
def print_fibonacci(n, count = 0):
    if count < n:
        print(fibonacci(count), end=" ")
        print_fibonacci(n, count + 1)
        
print_fibonacci(10)
    
# for i in range(10):
#     print(fibonacci(i), end = " ")


# In[30]:


# 24 Matrix Multiplication

X = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
Y = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
result = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

for i in range(len(X)):
    for j in range(len(Y[0])):
        for k in range(len(Y)):
            result [i][j] += X[i][j] * Y[k][j]
            
for r in result:
    print(r)


# In[31]:


# 25. Palindrome Check

def is_palindrome(s):
    return s == s[::-1]

print(is_palindrome("madam"))


# In[32]:


# 26 Merge Sort implementation

def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr)//2
        left_half = arr[:mid]
        right_half = arr[mid:]
        
        merge_sort(left_half)
        merge_sort(right_half)
        
        i = j = k = 0
        
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k+=1
        
        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1
            
        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1

arr = [12, 11, 13, 5, 6, 7]
merge_sort(arr)
print(arr)


# In[33]:


# 27 Sorting a List of Dictionaries

students = [
    {'name': 'Alice', 'age': 25},
    {'name': 'Bob', 'age': 20},
    {'name': 'Charlie', 'age': 23}
]

sorted_students = sorted(students, key = lambda x: x['age'])

print(sorted_students)


# In[34]:


# 28 Random Number Generation

import random

rand_int = random.randint(1, 100)
rand_float = random.uniform(1.0, 10.0)
rand_choice = random.choice(['apple', 'banana','cherry'])

print(rand_int, rand_float, rand_choice)


# In[35]:


# 29 Date and Time

import datetime

# Get current date and time
now = datetime.datetime.now()

print("current date and time:", now)

# Date manipulation
yesterday = now - datetime.timedelta(days = 1)
print("Yesterday's date:", yesterday)

# Formatting date

formatted_date = now.strftime("%Y-%m-%d %H:%M:%S")

print("Formated date :",formatted_date)


# In[36]:


# 30 Regular Expressions

import re

# Search for a pattrn in a string
pattern = r"\d+" # one or more digits

text = "My phone number is 123-456-7890"

matches = re.findall(pattern, text)
print(matches) # output: ['123', '456', '7890']

# Replace patterns in a string

new_txt = re.sub(r"\d+", "[REDACTED]", text)

print(new_txt)


# In[37]:


# 31 Json Handling

import json

# Dictionary to JSON

person_dict = {
    "name": "John",
    "age": 30,
    "city": "New York"
}

# Convert Dictionary to JSON

person_json = json.dumps(person_dict)

print(person_json)

# Convert JSON string to dict

person_from_json = json.loads(person_json)

print(person_from_json)


# In[38]:


# 32 Threading With Locks

import threading

# Thread-safe counter example

counter = 0
counter_lock = threading.Lock()

def increment_counter():
    global counter
    with counter_lock:
        for _ in range(10):
            counter += 1
            
threads = []
for _ in range(5):
    thread = threading.Thread(target = increment_counter)
    threads.append(thread)
    thread.start()
    
for thread in threads:
    thread.join()

print("Final Counter value:", counter)


# In[39]:


# 33 Argparse For Command-Line Arguments

import argparse

# command line argument parsing

parser = argparse.ArgumentParser(description = "A simple example.")
parser.add_argument('name', type=str, help='Your name')
parser.add_argument('--age', type=int, help='Your age', default=18)

args = parser.parse_args()

print(f"Hello, {args.name}. You are {args.age} years old.")


# In[40]:


# 34 itertools for combinations and perutations

import itertools

items = ['a', 'b', 'c']

#Combinations
combinations = list(itertools.combinations(items, 2))

print("combinations:", combinations)

#Permutations

permutations = list(itertools.permutations(items))
print("permutations",permutations)


# In[41]:


# 35 Asynchronous Programming 

import asyncio

# Asynchronous function example

async def say_hello():
    print("Hello")
    await asyncio.sleep(1)
    print("World")
    
# Running the async function

async def main():
    await asyncio.gather(say_hello(), say_hello())
    
await main()

# In standard Python scripts, you'd use asyncio.run(main()),
# but in Jupyter, using await main() works better.


# In[42]:


# 36 Comprehensions (set and dictionary)

# set comprehension

set_comp = {x for x in range(10) if x % 2 == 0}

print(set_comp)


# In[43]:


# dictionary comprehension

dict_comp = {x: x**2 for x in range(5)}
print(dict_comp)


# In[44]:


# 37 Using collections.Counter

# count frequency of elements in a list 

from collections import Counter

data = ['apple','banana','apple','orange','banana','apple']

count = Counter(data)

print(count)


# most common element
most_common = count.most_common(1)

print("most_coomon item is :",most_common)


# In[45]:


# 38 Working with Enums

from enum import Enum

# Enum example

class color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3
    
print(color.RED)
print(color.RED.name)
print(color.RED.value)


# In[46]:


# 39 Dataclasses

from dataclasses import dataclass

# Dataclass example

@dataclass
class Car:
    make: str
    model: str
    year: int

car1 = Car(make="Toyota", model="camry",year=2020)
print(car1)


# In[47]:


# 40 Memoization using

from functools import lru_cache

# Memoized Fibonacci using lru_cache

@lru_cache(maxsize=None)

def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

print(fib(10))


# In[48]:


# 41 Custom Exceptions

class NegativeNumberError(Exception):
    pass

def check_possitive(number):
    if number < 0:
        raise NegativeNumberError("Negative number are not allowed")
    else:
        print(f"{number} is possitive")
        
check_possitive(5)
check_possitive(-1)


# In[49]:


# 42 Context Managers

# using a context manager(with statement)

with open("example.txt", "w") as file:
    file.write("Hello, world!")
    
# Custom context manager using class

class MyContextManager:
    def __enter__(self):
        print("Entering context...")
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        print("Exiting context...")
        
with MyContextManager() as cm:
    print("Inside the context block")


# In[50]:


# 43 Type hinting 

def add(a: int, b: int) -> int:
    return a+b

print(add(3,4))


# In[51]:


# 44 property Decorators

class Celsius:
    def __init__(self, temp = 0):
        self._temperature = temp
        
    @property
    def temperature(self):
        print("Getting temperature")
        return self._temperature
    
    @temperature.setter
    def temperature(self, value):
        if value < -273:
            raise ValueError("Temperature below -273 is not possible")
        print("setting temperature")
        self._temperature = value
        
c = Celsius()
c.temp = 37 # Setting Temperature
print(c.temp) # Getting temperature and output: 37


# In[52]:


# 45 Metaclasses

class MyMeta(type):
    def __new__(cls, name, bases, attrs):
        print(f"Creating class {name}")
        return super().__new__(cls, name, bases, attrs)
    
class MyClass(metaclass=MyMeta):
    def __init__(self):
        print("Instance created")
        
instance = MyClass()


# In[53]:


# 46 Multiple Inheritance

class Parent1:
    def greet(self):
        print("Hello from Parent1")

class Parent2:
    def greet(self):
        print("Hello from Parent2")
        
class Child(Parent1, Parent2):
    pass

obj = Child()

obj.greet()  

# Output: Hello from Parent1 
#(due to method resolution order)


# In[54]:


# Abstract Base Classes (ABC)

from abc import ABC, abstractmethod

# Abstract base class example

class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass
    
class Dog(Animal):
    def sound(self):
        return "woof!"
    
obj = Dog()
print(obj.sound())


# In[55]:


# 48 Using zip for Parellel Iteration

# parallel iteration with zip 
names = ['Alice', 'Bob', 'charlie']
ages = [25, 30, 35]

for name, age in zip(names, ages):
    print(f"{name} is {age} years old")


# In[56]:


# 49 Packing and Unpacking Arguments 

# Unpacking arguments

def multiply(a,b,c):
    return "multiplication :",a * b *c

args = [2, 3, 4]

result = multiply(*args)  # Unpacking the list into function arguments
print(*result)


def add(*numbers):
    return f"sum : {sum(numbers)}"

print(add(1,2,3,4,5))


# In[57]:


# 50 Namedtuples

from collections import namedtuple

# Define the namedtuple with the name 'Pt'
pt = namedtuple('gfcf', ['x','y','z'])

# Create an instance of Pt
p = pt(10, 20, 30)

print(p.x, p.y, p.z)


# In[58]:


# 51 Using Deque for Efficient deque

from collections import deque

dq = deque([1, 2, 3])

# Appending and popping from both ends

dq.append(4)
print(dq)


# In[59]:


dq.appendleft(0)
dq


# In[60]:


dq.pop()
dq


# In[61]:


dq.popleft()
dq


# In[62]:


print(dq)


# In[63]:


# 52 functional programming with filter and reduce

from functools import reduce

# filtering even numbers from a list

nums = [1, 2,3,4,5,6]

evens = list(filter(lambda x: x%2 == 0, nums))

print(evens)

# reducing a list to its products

product = reduce(lambda x, y: x * y, nums)
print("reduce func:",product)


# In[64]:


# 53 Using isinstance and issubclass

# checking object type with isinstance

print(isinstance(5, int))

print(isinstance("hello", str))


# In[65]:


# checking class hierachy with issubclass
class A:
    pass

class B(A):
    pass

print(issubclass(B, A)) # Output: True
print(issubclass(A, B))  # Output: False


# In[66]:


# 54 slot optimization for Memory Efficiency

class MyClass:
    __slots__ = ['x', 'y'] # Limiting attributes to save memory
    
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
obj = MyClass(10,20)

print(obj.x, obj.y)


# In[ ]:


pip install aiofiles


# In[72]:


# 55 Asynchronous File I/O

import aiofiles
import asyncio

# Asynchronous file read and write

async def async_file_operations():
    async with aiofiles.open('async_test.txt', 'w') as f:
        await f.write("Hello Async!")
        
    async with aiofiles.open('async_test.txt', 'r') as f:
        content = await f.read()
        print(content)

# Running the asynchronous function
# asyncio.run(async_file_operations())

# In an environment with an already running event loop, use await
await async_file_operations()


# In[82]:


# 56 Custom Iteratots

# Custom iterator class

class MyRange:
    def __init__(self, start, end):
        self.current = start
        self.end = end
        
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.current >= self.end:
            raise StopIteration
            
        else:
            self.current += 2
            return self.current - 1
    
my_range = MyRange(1, 5)

for num in my_range:
    print(num)


# In[83]:


# 57 Generators and Generator Expressions

# Generator example
def countdown(n):
    while n > 0:
        yield n
        n -= 1
        
for num in countdown(5):
    print(num)


# In[86]:


# Generator expression

squares = (x ** 2 for x in range(5))
for square in squares:
    print(square)


# In[88]:


# 58 Decorators with Arguments

def repeat(num_times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(num_times):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Hello, {name}!")
    
greet("sairaj")


# In[91]:


# 59 class level decorators

# Applying a decorator to all methods of a class

def debug_methods(cls):
    for key, value in vars(cls).items():
        if callable(value):
            setattr(cls, key, debug(value))
    return cls

def debug(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@debug_methods
class MyClass:
    def method1(self):
        print("method1 called")
        
    def method2(self):
        print("method2 called")

obj = MyClass()

obj.method1()  # Output: Calling method1
               #         Method1 called
    
obj.method2()  # Output: Calling method2
               #         Method2 called


# In[94]:


# 60 Custom context Managers with contextlib


from contextlib import contextmanager

# custom context manager with contextlib
@contextmanager
def open_file(file_name, mode):
    f = open(file_name, mode)
    yield f
    f.close()
    
with open_file("test.txt", "w") as f:
    f.write("Hello, World!")
    
with open_file("test.txt", "r") as f:
    print(f.read())


# In[95]:


# 61 Partial Functions with functools.partial

from functools import partial

def multiply(x, y):
    return x * y

double = partial(multiply, 2)

print(double(5))


# In[98]:


# 62 Attribute Access and getattr, setattr, hasattr

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
        
person = Person("alice", 30)

# Get Attribute

print(getattr(person, 'name'))

# Set Attribute

setattr(person, 'name', 'bob')
print(person.name)


# check if attribute exists

print(hasattr(person, 'age'))


# In[105]:


# 63 Object Copying (copy and deepcopy)

import copy

# shallow copy

list1 = [1,2,[3,4]]
list2 = copy.copy(list1)
list2[2][0] = 9

print(list1) # Output: [1, 2, [9, 4]] (changes reflect in both)


# In[104]:


# Deep copy

import copy

list3 = [4,5,[7,8]]

list4 = copy.deepcopy(list3)

list4[2][0] = 6
print(list3) # (no change)
print(list4)


# In[106]:


# 65  Binary data Handling

with open("binary_file.bin", "wb") as f:
    f.write(b"\x00\xFF\x00\xFF")
    
with open("binary_file.bin", "rb") as f:
    data = f.read()
    print(data)


# In[109]:


# 66 Introspection (dir, type, help)

class MyClass:
    def method(self):
        pass
    
obj = MyClass()

# Getting the list of attributes and methods of an object
print(type(obj))

# Getting help on a class
help(MyClass)


# In[110]:


# 67. Global and Nonlocal Variables

# Global Variable example

x = 10 

def modify_global():
    global x
    x = 20
    

modify_global()

print(x)


# In[112]:


# Nonlocal variable example

def outer_function():
    y = 10
    def inner_function():
        nonlocal y
        y = 20
    inner_function()
    print(y)

outer_function()


# In[118]:


# 68 Multithreading with concurrent.futures

import concurrent.futures
import time

def task(n):
    time.sleep(1)
    return n * n

# Using ThreadPoolExecutor for multithreading

with concurrent.futures.ThreadPoolExecutor() as executor:
    futures = [executor.submit(task, i) for i in range(5)]
    for future in  concurrent.futures.as_completed(futures):
        print(future.result(), end=" ")


# In[122]:


# 69 Multiprocessing with concurrent.futures

import concurrent.futures

def task(n):
    return n * n

# Using ProcessPoolExecutor for multiprocessing

with concurrent.futures.ProcessPoolExecutor() as executor:
    results = list(executor.map(task, range(5)))
    
print(results)


# In[123]:


# 70 Serialization with pickle

import pickle

# Serialize (pickle) an object
data = {'key': 'value', 'number': 42}

with open('data.pk1', 'wb') as f:
    pickle.dump(data, f)
    
# Deserialize (unpickle) an object

with open('data.pk1', 'rb') as f:
    loaded_data = pickle.load(f)
    print(loaded_data)


# In[128]:


# 71 UUID generation

import uuid

# generate a random UUID

unique_id = uuid.uuid4()
print(unique_id)


# In[136]:


# 72 Handling Timezones with pytz

from datetime import datetime
import pytz

# set the timezone

timezone = pytz.timezone('Asia/Kolkata')

# Get the current time in the specified timezone

now = datetime.now(timezone)
print(now.strftime('%Y-%m-%d %H-%M-%S %Z%z'))


# In[139]:


# 73 SQLAlchemy ORM for Databases

from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Set up the SQLite database and ORM

engine = create_engine('sqlite:///:memory:')

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key = True)
    name = Column(String)
    
# Create an engine and a session
engine = create_engine('sqlite:///users.db')
Base.metadata.create_all(engine)

Session = sessionmaker(bind=engine)
session = Session()

# Add a user to the database

new_user = User(name='Alice')
session.add(new_user)
session.commit()

# Query the databases

for user in session.query(User):
    print(user.name)


# In[14]:


# Merge two sorted lists

def merge_sorted_lists(lst1, lst2):
    result = []
    i,j = 0,0
    
    # Merge the lists while both have elements
    while i < len(lst1) and j < len(lst2):
        if lst1[i] < lst2[j]:
            result.append(lst1[i])
            i += 1
        else:
            result.append(lst2[j])
            j += 1
            
    # Append remaining elements
    result.extend(lst1[i:]) # result += lst1[i:]
    result.extend(lst2[j:]) # result += lst2[j:]
    
    return result

print(merge_sorted_lists([1, 3, 5], [2, 4, 6]))


# In[24]:


import heapq

lst1 = [1, 2, 3, 5]
lst2 = [2, 4, 5, 6]

res = list(heapq.merge(lst1, lst2))

print(res)


def merged_sorted_lists(lst1, lst2):
    return sorted(lst1 + lst2)

print("Merged_sorted_list=>",merged_sorted_lists(lst1,lst2))


# 

# In[1]:





# In[15]:


# Next_Permutation

def next_permutation(arr):
    n = len(arr)
    
    # step 1: find the first decresing element from the right
    i = n - 2
    
    while i >= 0 and arr[i] >= arr[i+1]:
        i -= 1
        
    if i >= 0: # step 2: Find the element just larger than arr[i]
        j = n-1
        while arr[j] <= arr[i]:
            j -= 1
            
        # swap the elements
        arr[i], arr[j] = arr[j], arr[i]
        
    # step 3: Reverse the suffix
    arr[i + 1:] = reversed(arr[i + 1:])
        
    return arr
    

print(next_permutation([2, 4, 7, 1, 0, 5]))
print(next_permutation([1, 2, 3, 5, 6, 4]))


# In[11]:


print(next_permutation([3, 2, 1]))


# In[ ]:





# In[18]:


def checkOddEven(x):
    if(x % 2 == 0):
      # Complete the statement below
      return "Even"
    else:
        # Complete the statement below
        return "Odd"
    
checkOddEven(6)


# 

# In[31]:





# 

# In[2]:





# In[9]:





# In[20]:





# In[28]:





# In[33]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[70]:


import sys

# List all built-in modules
print(sys.builtin_module_names)


# # Scipy

# In[73]:


from scipy.optimize import fsolve

# Define the equation
def equation(B):
    return 85.64165 * B**3 + 875.025 * B**2 - 2340

# Initial guess
B_initial_guess = 1

# Solve for B
B_solution = fsolve(equation, B_initial_guess)

B_solution[0]


# In[5]:


def trim(str):
    return str.strip()   

def exists(str, x):
    return str.find(x)   

def titleIt(str):
    return str.title()    

def casesSwap(str):
    return str.swapcase()

print(trim("hello"))


# In[6]:


print(exists("hello", "llo"))


# In[7]:


titleIt("hello")


# In[8]:


casesSwap("hElLo")


# # SwAp_CaSe:

# In[74]:


def swap_case(s):
    ans=""
    for i in s:
        if i.isupper():
            ans+=i.lower()
        elif i.islower():
            ans+=i.upper()
        else:
            ans+=i
    print("swap_case string=",ans)
    
s=input()
swap_case(s)


# ### S.startswith('string2'), and S.endswith('string2')

# In[3]:


def gfg(S):
    b = S.lower()
    if(b.startswith("gfg") and b.endswith("gfg")):  
        print ("Yes")
    else:
        print ("No")
        
        
S = "gFgabcdEGfG"

gfg(S)


# # Upper(),lower(),capitalize()

# In[ ]:


s = input("name:")

result = s.upper()  # apple ==> APPLE

capital = s.capitalize() # eagle ==> Eagle

print(result)

print(type(s))

print(capital)


# # to capitalize_first_letter_of_each_word  

# In[ ]:


def capitalize_first_letter(sentence):
    words = sentence.split()
    capitalized_words = [i.capitalize() for i in words]
    return ' '.join(capitalized_words)

sentence = "this is a sample sentence"
print(capitalize_first_letter(sentence))

print(type(capitalize_first_letter(sentence)))


# ## title() function

# In[ ]:


sentence = "this is a sample sentence"
sentence.title()


# # split() and join() 

# In[ ]:


def split_and_join(line):
   a=line.split()
   print(a)         #$ variable.split()
    
   b='-'.join(a)  
   print(b)         # '-'.join(variable)
   return a,b

if __name__ == '__main__':
    line = input()
    result = split_and_join(line)
    print(result)


# In[ ]:


zuz="chris alan"
a=zuz.split()
print(list(a))
for i in a:
    print(i.capitalize(),end=" ")


# # import textwrap  ## textwrap.wrap(text,width)

# In[26]:


import textwrap
print(dir(textwrap))


# In[25]:


import textwrap

h="AABCAAADA"
k=3
sub_s=textwrap.wrap(h,k)
print(sub_s)
for i in sub_s:
    u="".join(set(i))
    print(u)


# In[27]:


import textwrap

def wrap(string, max_width):
    # Use textwrap.wrap() with the provided max_width
    wrapped_lines = textwrap.wrap(string, max_width)
    
    # Join the wrapped lines into a single string using '\n' as the separator
    wrapped_string = '\n'.join(wrapped_lines)
    
    # Return the wrapped string
    return wrapped_string

# Example usage:
wrapped_text = wrap("This is a long string that we want to wrap within a certain width to make it easier to read.", 20)
print(wrapped_text)


# In[28]:


# tcs nqt
"""
input: 
    bbbaaababa >> value of str
    3 >> val of L
    
output:
    3 >> maximum No. of a's
"""

str = input()
n = int(input())

max_val = 0
count = 0
for i in range(len(str)):
    if i%n==0:                             # 0%3==0 & 3%3==0 & 6%3==0 
        max_val = max(count, max_val)
        count = 0
    if str[i]=='a':
        count+=1
    
if count > max_val:
    max_val = count
    
print(max_val)


# In[ ]:





# In[29]:


import textwrap

wr = textwrap.wrap(str,n)
print(wr)
len_a=0
for i in range(len(wr)):
    if 'a' in wr[i]:
        len_a+=1
print(len_a)


# In[30]:


#HackerRank Problem

s = "AABCAAADA"
k = 3
sub = ""
l = len(s)
lst=[]
for i in range(l):
    sub += s[i]
    if len(sub) == k:
        # Remove duplicates from the substring
        sub_2 =''.join(sorted(set(sub), key=sub.index))
        lst.append(sub_2)
        print(sub_2)
        sub=""
print(lst)


# # Dictionary

# In[49]:


# Data
names = ["john", "ala", "ilia", "sudan", "mercy"]
marks = [100, 200, 150, 80, 300]

names, marks = arr

def create_dict(arr):
    #unpack the tuple into names and marks
    
    
    return {name:mark for name,mark in zip(names, marks)}



result = create_dict(arr)

print(result)


# In[42]:


def create_dict(arr):
    
    dict = {}
    
    for name, mark in arr:
        dict[name] = mark
    
    
    
    return dict


arr = [("john", 100), ("ala", 200), ("ilia", 150), ("sudan", 80), ("mercy", 300)]

create_dict(arr)


# In[ ]:


# insert into dictionary
def insert_dict(query, dict):
    dict[query[1]]=query[2]
    
    

# deleting from dictionary
def del_dict(query, dict):
    if(query[1] in dict):
        del dict[query[1]]
        return True
    else:
        return False
    
    
    

# print marks of required name
def print_dict(key, dict):
    if key in dict:
        print(f"Marks of {key} is {dict[key]}")
    else:
        return False


# # get() method
# 
# the get() method is used with dictionaries. It provides a way to safely access values by their keys without raising a KeyError if the key is missing.
# 
# 
# # syntax
# 
# ​
# dict.get(key, default_value)

# In[3]:


s = "itnisinitsithhn"

ch = {}

for i in s:
    if i in ch:
        ch[i] += 1
    else:
        ch[i] = 1
        
print(ch)

max_char = max(ch,key = ch.get)

max_value = ch.get(max_char)

print(max_char, max_value)


# In[4]:


data = {'user': {'name': 'Alice', 'age': 30}}

# Safe access
name = data.get('user', {}).get('name', 'Unknown')
print(name)  # Output: Alice

# Missing key
address = data.get('user', {}).get('address', 'No address provided')
print(address)  # Output: No address provided


# # Fibonacii

# In[62]:


def countFibonacciNumbers(arr):
        n = max(arr)
        fib = set()
        a = 0
        b = 1
        counter = 0
        while a <= n:
            fib.add(a)
            a, b = b, a+b
        
        for i in arr:
            if i in fib:
                counter+=1
        
        return counter
arr = [4, 2, 8, 5, 20, 1, 40, 13, 5, 23]

countFibonacciNumbers(arr)


# In[101]:


# Given a positive integer N, find the Nth Even Fibonacci number

def nthEvenFibonacci (n):
        l = list()
        a = 0
        b = 1
        for i in range(10000000000000000000):
            a, b = b , a+b
            if a % 2 == 0:
                l.append(a)
            if len(l) == n:
                break
        print(l[n-1])
        print(l)
        
nthEvenFibonacci (22)


# In[103]:


def nthEvenFibonacci(n):
    MOD = 1000000007

    # Base cases
    if n == 1:
        return 2
    if n == 2:
        return 8

    # Iterative computation of even Fibonacci numbers
    prev2, prev1 = 2, 8  # E_1 = 2, E_2 = 8

    for _ in range(3, n + 1):
        current = (4 * prev1 + prev2) % MOD
        prev2, prev1 = prev1, current

    return prev1

# Example Usage
n = 345
result = nthEvenFibonacci(n)
print(result)  # Output: 829778862


# # Dictionary Comprehension

# In[31]:


import random

names = ['Alex', 'Emilia', 'John', 'Ross', 'Clark', 'Joey']

#syntax :

# dict = {new_key:new_value for item in iterable}


student_scores = {student:random.randint(20,100) for student in names}

print(student_scores)


# In[32]:


# conditional dictionary comprehension

# syntax :

# new_dict = {new_key:new_value for (key,value) in dict.items() if condtion}


passed_students = {student:score for (student, score) in student_scores.items() if score >= 40}

print(passed_students)


# In[33]:


sentence = "What is the Airspeed Velocity of an Unladen Swallow?"


result = {word:len(word) for word in sentence.split()}
print(result)


# In[34]:


weather_c = {"Monday": 12, "Tuesday": 14, "Wednesday": 15, "Thursday": 14, "Friday": 21, "Saturday": 22, "Sunday": 24}

weather_f = {day:temp_c*9/5+32 for (day, temp_c) in weather_c.items()}

print(weather_f)


# In[ ]:





# # LAMBDA FUNCTION

# In[35]:


sum = lambda a, b: a + b
print(sum(3, 4))


# In[36]:


point2D = [(1,2),(15,1),(5,-1),(20,3)]

point_2D_sorted = sorted(point2D , key = lambda x:x[0] + x[1]) # sort on thr basis of sum of two numbers
print(point_2D_sorted)


# In[ ]:





# In[ ]:


python_students = [['Harry', 37.21,'a'], ['Berry', 37.21,'b'], ['Tina', 37.2,'d'], ['Akriti', 41,'e'], ['Harsh', 39,'c']]

#python_students.sort(key=lambda x: x[1]) creates Object  
                            
# Sort the list of students based by their grades
sorted_data = sorted(python_students, key=lambda x: x[1])
print("using sorted__",sorted_data)

python_students.sort(key=lambda x: x[2],reverse = True) # Sort the list of students based by letters
print("reverse letters sorted :",python_students)


# In[ ]:


python_students.sort()   # Sort the list of students based by their names
print(python_students)


# ####  Print names of students with the second lowest grade

# In[ ]:


python_students = [['Harry', 37.21], ['Berry', 37.21], ['Tina', 37.2], ['Akriti', 41], ['Harsh', 39]]

# Sort the list of students based on their grades
python_students.sort(key=lambda x: x[1])

# Find the second lowest grade

second_lowest_grade = sorted(set(i[1] for i in python_students))[1]

#for sorting names
python_students.sort()

# Print names of students with the second lowest grade
for student in python_students:
    if student[1] == second_lowest_grade:
        print(student[0])


# In[ ]:


# Given list of students and their grades
python_students = [['Akriti', 41], ['Harsh', 39], ['Berry', 37.21], ['Harry', 37.21], ['Tina', 37.2]]

# Sorting the list by grades
sorted_students = sorted(python_students, key=lambda x: x[1])

# Finding the second lowest grade
grades = []
for i in sorted_students:
    grades.append(i[1])
second_lowest_grade = sorted(set(grades))[1]

# Finding students with the second lowest grade
for student in python_students:
    if student[1] == second_lowest_grade:
        print(student[0])

# Output the second lowest grade and students
print("Second Lowest Grade:", second_lowest_grade)


# ## difference_map & filter

# In[37]:


#filter
def is_even(num):
    return num % 2 == 0

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
filtered_numbers = list(filter(is_even, numbers))

print(filtered_numbers) 


# In[38]:


#map
def is_even(num):
    return num % 2 == 0

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
filtered_numbers = list(map(is_even, numbers))

print(filtered_numbers) 


# ## filter(lambda)

# In[39]:


lst=[10,20,30,-1,-2,-3]
res=tuple(filter(lambda x:x<0,lst))
print("negative tuple",res)


res=list(filter(lambda x:x>0,lst))
print("possitive list",res)


# # map
Purpose: 
    The 'map' function is used to apply a specific function to each item in an iterable (like a list or array) and
    return a new iterable with the results.
    
How it works: 
    You provide a function and an iterable, and 'map' applies the function to each element of the iterable,
    returning a new iterable of the transformed elements.
# ## map(lambda)

# In[ ]:


lsti=[1,2,3,4,5]
res=list(map(lambda x:x**3,lsti))
print(res)


# In[ ]:


import functools 
print(dir(functools))


# ## reduce(lambda)
Purpose: 
    The 'reduce' function is used to apply a binary function cumulatively to the items of an iterable,
    reducing it to a single value.
    
How it works:
    You provide a binary function (a function that takes two arguments) and an iterable, and 
    reduce applies the function to the first two elements, then to the result and the next element, and 
    so on, until the iterable is reduced to a single value.
# In[ ]:


from functools import reduce

numbers = [1, 2, 3, 4, 5]
result = reduce(lambda x, y: x + y, numbers)

print(result)


# In[ ]:


from functools import reduce

numbers = [7, 2, 9, 1, 5]
result = reduce(lambda x, y: x if x > y else y, numbers)

print(result)


# In[ ]:


#  implementing max() function, using 
import functools
print (functools.reduce(lambda a,b: a if (a > b) else b, [7, 12, 45, 100, 15]))


# In[ ]:


from functools import reduce
print (reduce(lambda a,b: a if (a > b) else b, [7, 12, 45, 100, 15]))


# In[ ]:


from functools import reduce
from collections import Counter

words = ["apple", "banana", "apple", "orange", "banana", "banana"]
frequency = reduce(lambda acc, word: acc.update({word: acc.get(word, 0) + 1}) or acc, words, Counter())
print(frequency)  # Output: Counter({'banana': 3, 'apple': 2, 'orange': 1})
("")


# # collections : Counter , namedtuple , orderedDict , defaultdict , deque

# In[ ]:


import collections
print(dir(collections))


# # Counter

# #                      from collections import Counter  ## C is capital in Counter

# In[ ]:


from collections import Counter 

                        # C is capital in Counter

myList = [1,1,2,3,4,5,3,2,3,4,2,1,2,3]

print(Counter(myList))


# In[ ]:


#print in a sorted manner and their counts 
print(Counter(myList).items())


# In[ ]:


from collections import Counter

myList = ['a','b','c','a','n','b','s','d','c','b','a','n','d','a','c']
b=Counter(myList)
print(b)


# In[ ]:


a=Counter(myList).items()
print(a)


# In[ ]:


from collections import Counter
a="aaaaabbbbcccdd"
my_count=Counter(a)
print(my_count.most_common(1)) 
                                # counter(var).most_common(index_upto) 
print(Counter(a).most_common(2))
print(Counter(a).most_common(3))
print("###")
print(my_count.most_common(1)[0][0])     #   most_common


# The first line contains , the number of shoes.
# The second line contains the space separated list of all the shoe sizes in the shop.
# The third line contains , the number of customers.
# The next  lines contain the space separated values of the size desired by the customer and , the price of the shoe.

# In[ ]:


n= int(input('the number of shoes:'))
stock = list(map(int,input('the space separated list of all the shoe sizes in the shop:').split()))

x=int(input('the number of customers:'))

from collections import Counter

dict=Counter(stock)
print(dict)

p=0
for i in range(x):
    size,price = map(int,input().split())
    
    if(dict[size]):
        dict[size]-=1
        p+=price
        
print(p)


# In[ ]:


a = "Harry Potter and The Prisoner Of Azkaban"
a = a.casefold()
print(a)
v = "aeiou"

count={}.fromkeys(v,0)

print(count)

for i in a:
    if i in v:
        count[i]+=1
print("----#----#-----#-----#----#----")
print(count)


# In[ ]:


from collections import Counter

a= "Harry potter and The Prisoner Of Azkaban"

a=a.casefold()

v="aeiou"

c=Counter(a)
print(c)
d={}
for i in c:
    if i in v:
        d[i] = c[i]

print(d)


# ## OrderedDict : 

# In[ ]:


from collections import OrderedDict

dct=OrderedDict()

dct['c']=3
dct['b']=2
dct['d']=4
dct['a']=1

print(dct)


# In[ ]:


print(dict(dct))


# In[ ]:





# # defaultdict :

# In[40]:


from collections import defaultdict

d = defaultdict(int)
d['a'] = 2
d['b'] = 1

print(d)
print("if key not present print default value",d['c']) #default Value 0
print(dict(d))


# In[43]:


from collections import defaultdict

n, m = map(int, input().split())
lst_m = []
d = defaultdict(list)
for i in range(n):
    d[str(input())].append(i+1)
for i in range(m):
    lst_m.append(str(input()))
for item in lst_m:
    if item in d.keys():
        print(*d[item])
    else:
        print(-1)


# STDIN   Function
# -----   --------
# 5 2     group A size n = 5, group B size m = 2
# a       group A contains 'a', 'a', 'b', 'a', 'b'
# a
# b
# a
# b
# a       group B contains 'a', 'b'
# b
# 
# 
# Sample Output
# 
# 1 2 4
# 3 5

# In[45]:


from collections import defaultdict

n, m = map(int, input().split())

D= defaultdict(list)

for i in range(n):
    s = input().rstrip()
    D[s].append(i+1)

for i in range(m):
    s = input().rstrip()
    
    if s in D:
        print(' '.join(map(str, D[s])))
    else:
        print("-1")


# In[ ]:


from collections import defaultdict
n, m = map(int, input().split())
a = defaultdict(list)
for i in range(1, n+1):
    a[input()].append(i)
for _ in range(m):
    print(*a.get(input()) or [-1])


# # deque

# In[52]:


from collections import deque

d = deque()

d.append(1)
d.append(2)
print(d)

d.appendleft(3)  # adding value to left
print(list(d))
print(type(d))


# In[47]:


e=[9,8,7]
d.extend(e)
print(d)


# In[48]:


f = [5,6,7]
d.extendleft(f)
print(d) # extending the list in FIFO


# In[49]:


print(d)
d.rotate(-1)  # rotate list to left side by 1 position
print(d)
d.rotate(2)
print(d) # rotate list to right side by 2 position


# In[ ]:


d.clear()
print(d)


# In[55]:





# # namedtuple

# In[ ]:


from collections import namedtuple
ND = namedtuple('Point','x,y')
pt1 = Point(1,2)
pt2 = Point(3,4)
dot_product = ( pt1.x * pt2.x ) +( pt1.y * pt2.y )
             # (1 * 3) + (2 * 4)
print(dot_product)
print(f"pt1.x = {pt1.x}")
print(f"pt2.x = {pt2.x}")
print(f"pt1.y = {pt1.y}")
print(f"pt2.y = {pt2.y}")


# In[ ]:


from collections import namedtuple
Car = namedtuple('Car',())


# In[ ]:



from collections import namedtuple

n = int(input())

column_names = input().split()

total_marks = 0
for i in range(n):
    stu = namedtuple('student', column_names)
    MARKS, CLASS, NAME, ID = input().split()
    
    student = stu(MARKS, CLASS, NAME, ID)
    total_marks += int(student.MARKS)
    
    avg = total_marks/n
    
print('{:.2f}'.format(avg))


# # itertools : product , permutations , accumulate , groupby , count 

# In[ ]:


import itertools
print(dir(itertools))


# # product

# In[ ]:


s, k = input().split()
k = int(k)
print(s, k)


# In[ ]:


from itertools import product

A=list(map(int, input().split()))
B=list(map(int, input().split()))

C=list(product(A, B))

for i in C:
    print(i,end=" ") 


# In[ ]:


from itertools import product

a = [1,2]
b = [3,4]
pro = product(a,b) # cartesian product of two matrix

print(pro)

print(list(pro))


# In[ ]:


c = [1,3,5]
d = [2,4,6]


mat_rix = product(c,d)

print(list(mat_rix))


# In[ ]:


from itertools import product
A = [[1,2,3],[3,4,5]]
print(list(product(*A)))

#[(1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 3), (3, 4), (3, 5)]


# # permutations

# In[ ]:


from itertools import permutations
s, k = input().split()
k = int(k)

p = permutations(s,k)
#print(list(p))

for i in sorted(list(p)):
    print("".join(i))


# In[ ]:





# In[ ]:


from itertools import permutations
a = [1,2,3]

pems = permutations(a)

print(pems)

print(list(pems)) 


# In[ ]:


# permutations of different length 

pems = permutations(a,2)

print(list(pems))


# In[ ]:





# # combinations , combinations_with_replacement

# In[ ]:


from itertools import combinations

s, k = input().split()
k = int(k)
s = sorted(s)
comb_1 = combinations(s, 1)

comb_2 = combinations(s, k)

for i in (list(comb_1)):
    print("".join(i))

for i in (list(comb_2)):
    print("".join(i))
        


# In[ ]:





# In[ ]:


from itertools import combinations , combinations_with_replacement

c = [1,2,3]

comb = combinations(c,2) # here lenghth is mandatory 

print(list(comb)) # it does not create duplicates combination


# In[ ]:





# In[ ]:


from itertools import combinations_with_replacement

s, k = input().split()
s=sorted(s)
k=int(k)

c_WR = combinations_with_replacement(s, k)

for i in list(c_WR):
    print("".join(i))


# In[ ]:





# In[ ]:


#it creates all possible comination
comb_wr = combinations_with_replacement(c,2)

print(list(comb_wr))


# In[ ]:


g=[('a', 'a'), ('a', 'c'), ('a', 'd'), ('a', 'c'), ('a', 'd'), ('c', 'd')]

g[1][0] == 'a'
count = 0
for i in g:
    if 'a' in i:
        count+=1
print(count)


# In[ ]:


# Enter your code here. Read input from STDIN. Print output to STDOUT
from itertools import combinations

N = int(input())

y = input().split()

lower_case = map(str.lower, y)


r = int(input())

total =0
count = 0
comb = list(combinations(lower_case, r))

print(comb)

# for i in range(len(comb)):
#     if comb[i][0]=='a':
#         count+=1          

        #OR

for i in (comb):
    if 'a' in i:
        count+=1

list_len=len(comb)

print(list_len)
    

print(format(count/list_len,'.4f'))

#input:
# 4
# a a c d
# 2


# # group by

# In[ ]:


from itertools import groupby

persons = [{'name':'Tim','age':25},{'name':'Dan','age':27},{'name':'lisa','age':26},{'name':'claire','age':25}]

grp_obj = groupby(persons , key=lambda x:x['age'])

for key,value in grp_obj:
    print(key , list(value))


# # count,cycle,repeat
# 

# In[ ]:


from itertools import count,cycle,repeat


for i in count(10):
    if i == 15:
        break
    print(i)


# In[ ]:


from itertools import cycle
counter = 0
a=[1,2,3]
for i in cycle(a):         # cycle 
    if counter==9:
        break
    print(i)
    counter+=1


# In[ ]:


from itertools import repeat


for i in repeat(8,5):
    print(i)


# In[ ]:





# # Errors  :
# 
# 1 ==> Syntax Error : invalid syntax
# 
#                             2==> TypeError : unsupported operand 
# 
# 3 ==> ModuleNotFoundError : 
# 
#                             4==> NameError : name 'ex.' is not defined
# 
# 5 ==> FileNotFoundError : no such file or directory : 'filename.format'
# 
#                             6==> ValueError : value not in
# 
# 7 ==> IndexError : index out of range
# 
#                             8==> KeyError : 'keyname'
# 9 ==> ZeroDivisionError : division by zero
#                                 
#                            10==> EOFError : Raised when the input() function hits the end-of-file condition
# 11 ==> AssertionError : Raised when an assert statement fails
# 
#                             12==> OSError : Raised when system operation causes system related error
# 
# 13 ==> MemoryError : Raised when an operation runs out of memory

# # try and except:
# 

# In[ ]:


try:
    a = int(input("Enter value of a:"))
    b = int(input("Enter value of b:"))
    c = a/b
    print("The answer of a divide by b:", c)
except ValueError as v:
    print("Entered value is wrong")
    print("Error Code:",v)
except ZeroDivisionError as z:
    print("Can't divide by zero")
    print("Error Code:",z)


# In[ ]:


T = int(input()) 
for i in range(T): 
    try: 
        a, b = map(int, input().split()) 
        print(a//b) 
    except Exception as e: 
        print("Error Code:",e)  


# 

# In[ ]:


def simple_interest(amount, year, rate):
    try:
        if rate > 100:
            raise ValueError(rate)
        interest = (amount * year * rate) / 100
        print('The Simple Interest is', interest)
        return interest
    except ValueError as ve:
        print('Interest rate is out of range:', ve)

print('Case 1')
simple_interest(800, 6, 8)

print('Case 2')
simple_interest(800, 6, 800)


# ### Polar coordinates are an alternative way of representing Cartesian coordinates or Complex Numbers.

# In[ ]:


from cmath import polar
z=input()
complex_num=complex(z)
polar_form=polar(complex_num)
for i in polar_form:
    print(i)


# In[ ]:





# # Triangle

# In[ ]:


1
121
12321
1234321
123454321


# In[ ]:


for i in range(1,int(input())+1):
    print(i*'*')


# In[ ]:


for i in range(1,int(input())+1):
    print(str(i)*(i))


# In[ ]:


n=5
for i in range(1,n):
    print(" "*(n-i)+i*"#")


# In[ ]:


n = int(input("Enter number of rows: "))
alph = 65
for i in range(0, n):
    print(" " * (n-i), end=" ")
    for j in range(0, i+1):
        print(chr(alph), end=" ")
        alph += 1
    alph = 65
    #print("\r")
    print()


# In[ ]:


n = int(input("Enter number of rows: "))
alpha=65
for i in range(0,n):
    for j in range(1,n-i):
        print(" ",end="")
    for k in range(0,i+1):
        print(chr(alpha),end=" ")
        alpha+=1
    print("\r")
    #print()


# In[ ]:


k=n-1
for i in range(0, n):
     
        # inner loop to handle number spaces
        # values changing acc. to requirement
        for j in range(0, k):
            print(end="+")
     
        # decrementing k after each loop
        k = k - 1
     
        # inner loop to handle number of columns
        # values changing acc. to outer loop
        for s in range(0, i+1):
         
            # printing stars
            print("*", end="#") 
        print("\r")
k=0
for i in range(n-1,0,-1):
    k=k+1
    for j in range(0,k):
        print(end="+")
    for s in range(i,0,-1):
        print("*",end="@")
    print()


# #  .rstrip()

# ### The rstrip() method removes any trailing whitespace characters from the right side of the string. 
# 
# 
# ## This is useful to clean up the input and remove any unwanted spaces at the end.

# In[ ]:


n=3
arr=[]
for i in range(n):
        arr.append(list(map(int, input().rstrip().split())))
print(arr)


# In[ ]:


arr[2][2]


# In[ ]:


# 1+3+4
arr[0][0]+arr[1][1]+arr[2][2]


# In[ ]:


arr[0][2]+arr[1][1]+arr[2][1]


# In[ ]:





# # Python-interface module

# In[ ]:




In object-oriented languages like Python, the interface is a collection of method signatures that should be provided 
by the implementing class. Implementing an interface is a way of writing an organized code and achieve abstraction.

The package zope.interface provides an implementation of “object interfaces” for Python. 
It is maintained by the Zope Toolkit project. The package exports two objects, ‘Interface’ and ‘Attribute’ directly. 
It also exports several helper methods. It aims to provide stricter semantics and better error messages than 
Python’s built-in abc module.
# # Implementing interface: The interface acts as a blueprint for designing classes, 
#     so interfaces are implemented using the implementer decorator on the class. 
#     If a class implements an interface, then the instances of the class provide the interface. 
#     Objects can provide interfaces directly, in addition to what their classes implement.
#     
#     

# In[ ]:


'''
Syntax:  @zope.interface.implementer(*interfaces)
class Class_name:
   # methods
'''

import zope.interface 
	
	
class MyInterface(zope.interface.Interface): 
	x = zope.interface.Attribute("whatever") 
	def method1(self, x): 
		pass
	def method2(self): 
		pass
	
@zope.interface.implementer(MyInterface) 
class MyClass: 
	def method1(self, x): 
		return x**2
	def method2(self): 
		return "foo"
	
obj1 = MyClass() 

print(obj1.method1(5)) 
print(obj1.method2())


# In[ ]:


import zope.interface 


class BaseI(zope.interface.Interface): 
	def m1(self, x): 
		pass
	def m2(self): 
		pass

class DerivedI(BaseI): 
	def m3(self, x, y): 
		pass

@zope.interface.implementer(DerivedI) 
class cls: 
	def m1(self, z): 
		return z**3
	def m2(self): 
		return 'foo'
	def m3(self, x, y): 
		return x ^ y 
	
# Get base interfaces 
print(DerivedI.__bases__) 

# Ask whether baseI extends 
# DerivedI 
print(BaseI.extends(DerivedI)) 

# Ask whether baseI is equal to 
# or is extended by DerivedI 
print(BaseI.isEqualOrExtendedBy(DerivedI)) 

# Ask whether baseI is equal to 
# or extends DerivedI 
print(BaseI.isOrExtends(DerivedI)) 

# Ask whether DerivedI is equal 
# to or extends BaseI 
print(DerivedI.isOrExtends(DerivedI)) 


# # Difference between abstract class and interface in Python
What is an Abstract class in Python?

A blueprint for other classes might be thought of as an abstract class.
You may use it to define a collection of methods that are required for all subclasses derived from the abstract class.
An abstract class is one that includes one or more abstract methods.
A method that has a declaration but no implementation is said to be abstract.
We use an abstract class for creating huge functional units. 
An abstract class is used to offer a standard interface for various implementations of a component.
# # Abstract class 
Python does not come with any abstract classes by default. 
Python has a module called ABC that serves as the foundation for building Abstract Base Classes (ABC). 
ABC works by decorating methods of the base class as abstract and then registering concrete classes as 
implementations of the abstract base. When a method is decorated with the keyword @abstractmethod, it becomes abstract.
# In[ ]:


from abc import ABC, abstractmethod 
class Animal(ABC): 

	def move(self): 
		pass

class Human(Animal): 

	def move(self): 
		print("I can walk and run") 

class Snake(Animal): 

	def move(self): 
		print("I can crawl") 

class Dog(Animal): 

	def move(self): 
		print("I can bark") 

class Lion(Animal): 

	def move(self): 
		print("I can roar") 
		
# Driver code 
R = Human() 
R.move() 

K = Snake() 
K.move() 

R = Dog() 
R.move() 

K = Lion() 
K.move() 


# In[ ]:


# Python program invoking a 
# method using super()
from abc import ABC

class R(ABC):
    def rk(self):
        print("Abstract Base Class")

class K(R):
    def rk(self):
        super().rk()
        print("subclass ")

# Driver code
r = K()
r.rk()


# In[ ]:





# # Calendar

# ## class calendar.Calendar(firstweekday=0)
# Creates a Calendar object. firstweekday is an integer specifying the first day of the week. 
# MONDAY is 0 (the default), SUNDAY is 6.

# In[ ]:


import calendar

print(calendar.TextCalendar(firstweekday=6).formatyear(2024))


# In[ ]:


import calendar 
print ("The calendar of year 2018 is : ") 
print (calendar.calendar(2018))


# In[ ]:


import calendar 
   
yy = 2017
mm = 11
print(calendar.month(yy, mm)) 


# In[ ]:


import calendar

n1, n2, n3 = map(int, input().split())

print((calendar.day_name[calendar.weekday(n3, n1, n2)]).upper())


# In[ ]:


import calendar

n1, n2, n3 = map(int, input().split())

print((calendar.day_name[calendar.weekday(n3, n1, n2)]))


# In[ ]:


# import calendar

month, day, year = map(int, input().split())

print(calendar.datetime.datetime(year, month, day).strftime("%A").upper())


# #  Generator :

# In[ ]:


##Generator:
get_ipython().set_next_input('What Are Generators');get_ipython().run_line_magic('pinfo', 'Generators')

Generators are a type of iterable, like lists or tuples, but unlike lists, generators do not store their contents in memory.

Instead, they generate the next value on the fly, which makes them very efficient for working with large datasets.

How to Create Generators

Generator Functions: These are defined using the def keyword and contain one or more yield statements.
    
Generator Expressions: These are similar to list comprehensions but use parentheses instead of square brackets.


# In[ ]:


def count_up_to(max):
    count = 1
    while count <= max:
        yield count
        count += 1

# Using the generator
counter = count_up_to(5)
for number in counter:
    print(number)


# In[ ]:


# List comprehension
squares_list = [x * x for x in range(10)]

# Generator expression
squares_gen = (x * x for x in range(10))

# Using the generator
for square in squares_gen:
    print(square,end=" ")


# Advantages of Generators
# 
# Memory Efficiency: Generators are memory-efficient because they generate items one at a time and only when required.
# 
# Lazy Evaluation: They produce items only when needed, which can save time and resources, especially with large datasets.
# 
# Improved Performance: They can improve performance by yielding values instead of returning them all at once.

# In[ ]:


def generate_numbers(n):
    for i in range(n):
        yield i

def square_numbers(numbers):
    for number in numbers:
        yield number * number

def filter_even_numbers(numbers):
    for number in numbers:
        if number % 2 == 0:
            yield number

# Creating a pipeline
numbers = generate_numbers(10)
squared = square_numbers(numbers)
even_squares = filter_even_numbers(squared)

# Using the pipeline
for num in even_squares:
    print(num)


# # Decorator

# In[ ]:


get_ipython().set_next_input('What Are Decorators');get_ipython().run_line_magic('pinfo', 'Decorators')

A decorator is a function that takes another function as an argument, extends or alters its behavior, 
and returns a new function. 

They are often used for logging, access control, memoization, and more.


# In[ ]:


def decorator_function(original_function):
    def wrapper_function():
        print("Wrapper executed before {}".format(original_function.__name__))
        return original_function()
    return wrapper_function

@decorator_function
def display():
    print("Display function ran")

display()


# In[ ]:


def simple_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@simple_decorator
def say_hello():
    print("Hello!")

say_hello()


# In[ ]:





# In[ ]:


# append remove # leetcode 283

num = list(map(int, input().split()))
for i in num:
    if i == 0:
        num.remove(i)
        num.append(i)
    else:
        pass
print(num)


# In[ ]:





# In[ ]:


# Errors, Exception Handling


# In[ ]:


facebook_posts = [
    {'Likes': 21, 'Comments': 2},
    {'Likes': 13, 'Comments': 2, 'Shares': 1},
    {'Likes': 33, 'Comments': 8, 'Shares': 3},
    {'Comments': 4, 'Shares': 2},
    {'Comments': 1, 'Shares': 1},
    {'Likes': 19, 'Comments': 3}
]



def count_likes(posts):
    total_likes = 0
    for post in posts:
        try:
            total_likes = total_likes + post['Likes']
        
        except KeyError:
            # Handle when "Likes" key is missing
            pass       
    return total_likes


print(count_likes(facebook_posts))


# In[ ]:





# # get() method
In Python, the get() method is used with dictionaries. It provides a way to safely access values by their keys without raising a KeyError if the key is missing.
# In[ ]:


# syntax

dict.get(key, default_value)

Benefits of get():

1} Avoids KeyError: If the key is not found, it returns None or the specified default value, instead of raising an exception.

2} Default value handling: You can provide a default value to return if the key is missing.
# In[ ]:


my_dict = {'a': 1, 'b': 2, 'c': 3}

# Without using get()
value = my_dict['a']  # This works
# value = my_dict['z']  # This raises a KeyError

# Using get()
u = my_dict.get('a')  # Returns 1
v = my_dict.get('z')  # Returns None (key not found)
w = my_dict.get('z', 0)  # Returns 0 (key not found, default value provided)

print(u)
print(v)
print(w)

1] What is the difference between accessing a value using dict[key] and dict.get(key)?

Answer: dict[key] raises a KeyError if the key is missing, while dict.get(key) returns None or a specified default value.

2]What are some common use cases for the get() method?

Answer: Handling missing keys gracefully, assigning default values when fetching keys, and avoiding exceptions in large codebases.

3] Explain how get() can be useful in reading user-provided configuration files.

Answer: If configuration keys are optional, get() can be used to return default values in case some settings are not provided, thus avoiding crashes.

4] What is the time complexity of the get() method in Python dictionaries?

Answer: The time complexity of get() is
O(1) (constant time) because dictionary lookups are hash-based.
# In[ ]:


# Count word frequncy in a text

def word_frequency(text):
    words = text.split()
    freq = {}
    for word in words:
        freq[word] = freq.get(word, 0) + 1
    return freq

text = "this is a test and this is just a test"

print(word_frequency(text))


# In[ ]:


# Return the marks of a student by name, and if the student is not found, return -1

def get_marks(student_name, marks_dict):
    return marks_dict.get(student_name, -1)

marks = {'John': 85, 'Emily': 92, 'Lara': 78}

print(get_marks("John", marks))
print(get_marks("Rachel", marks))


# # Regex and parsing
# 
# <!-- Regular expressions are patterns used to match character combinations in strings. In Python, this is handled using the re module. -->

# $$ 1. Regular Expressions (Regex) Basics
# 
# 
# 1. \d: Matches any digit (0-9).
# 2. \D: Matches any non-digit.
# 3. \w: Matches any alphanumeric character (a-z, A-Z, 0-9, and _).
# 4. \W: Matches any non-word character.
# 5. \s: Matches any whitespace character (space, tab, newline).
# 6. \S: Matches any non-whitespace character.
# 
# $$ Anchors:
# 
# 1. ^: Matches the start of a string.
# 2. $: Matches the end of a string.
# 
# 
# $$ Quantifiers:
# 
# 1. *: Matches 0 or more repetitions.
# 2. +: Matches 1 or more repetitions.
# 3. ?: Matches 0 or 1 repetition.
# 4. {m}: Matches exactly m repetitions.
# 5. {m, n}: Matches from m to n repetitions.
# 
# 
# $$ Groups and Alternation:
# 
# 1. (abc): Matches the exact sequence abc.
# 
# 2. (a|b): Matches either a or b.
# 
# 

# 
# $$ Regex Functions in Python
# 
# 
# 1. re.match(pattern, string): Determines if the pattern matches at the start of the string.
# 
# 2. re.search(pattern, string): Scans through the string looking for any location where the pattern matches.
# 
# 3. re.findall(pattern, string): Returns all matches of a pattern in a string.
# 
# 4. re.sub(pattern, repl, string): Replaces all matches of the pattern in a string with repl.
# 
# 5. re.split(pattern, string): Splits the string wherever the pattern matches.

# In[ ]:


# matching specific string patterns (^hackerrank)

# ^: Matches the start of a string.

import re

# Example usage

test_strings = ["hackerrank123", "hackerrank abc", " abc hackerrank", "hackerrank"]

for s in test_strings:
    if re.match(r'^hackerrank',s):
        print(f"'{s}' matches")
    else:
        print(f" '{s}' does not match")


# In[ ]:


# Validating email address

# Pattern: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$

import re

emails = ["example@test.com", "user@domain.org", "invalid-email@", "@missingusername.com"]

for email in emails:
    if re.match(r'^[a-zA-Z09._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',email):
        print(f"'{email}' is valid")
    else:
        print(f"'{email}' is not valid")


# In[16]:


# Extracting Information with Groups extract the name, age, and city.

# Pattern: User:\s*(\w+\s+\w+),\s*Age:\s*(\d+),\s*City:\s*(\w+\s*\w*)

import re

text = "User: John Doe, Age: 28, City: New York"

match = re.search(r"User:\s*(\w+\s+\w+),\s*Age:\s*(\d+),\s*City:\s*(\w+\s*\w*)", text)

if match:
    name, age, city = match.groups()
    print(f"Name:{name}, Age:{age}, City:{city}")


# In[15]:


# Basic Regex for a 10-Digit Phone Number

import re

n = ["9587456281", "1252478965", "7896541230", "+919876543210", "+91 9587456281"]

for number in n:
    if re.match(r'^(\+91[-\s]?)?[6789]\d{9}$', number):
        print(f"'{number}' Yes")
    else:
        print("No")


# In[14]:


import re
def validate(str):
    pat= "[a-z]+[!@#$%]+[0-9]"
    match = re.search(pat, str)
    if(match):
        return True
    else:
        return False
    
    
str1 = "asdsab@!@234"    
validate(str1)


# In[36]:


def numberMatcher(str):
#     pat= "[0-9]+"
    pat= '\d+'
    match=re.findall(pat,str) ##find all finds all the matched texts and returns a list
    if(match): 
        for i in match:
            print(i, end=" ")
    else:
        print(-1,end="")
        
strx = "asdasd123asmdasdk34234kfdsd34sdfk5"
numberMatcher(strx)


# In[ ]:




